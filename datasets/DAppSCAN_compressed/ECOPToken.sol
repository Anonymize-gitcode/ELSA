pragma solidity ^0.5.10;

contract owned { address public owner; constructor() public { owner = msg.sender; }

function transferOwnership(address newOwner) onlyOwner public { if (newOwner != address(0)) { owner = newOwner; } } } interface IERC20 { function totalSupply() external view returns (uint256); function balanceOf(address account) external view returns (uint256); function allowance(address owner, address spender) external view returns (uint256); function decimals() external view returns (uint8); function transfer(address recipient, uint256 amount) external returns (bool); function approve(address spender, uint256 amount) external returns (bool); function transferFrom(address sender, address recipient, uint256 amount) external returns (bool); function burn(uint256 _value) external returns (bool success); function burnFrom(address _from, uint256 _value) external returns (bool success); event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed owner, address indexed spender, uint256 value); event Burn(address indexed from, uint256 value); } pragma solidity >=0.5.0 <0.7.0; library SafeMath { function add(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a + b; require(c >= a, "SafeMath: addition overflow"); return c; } function sub(uint256 a, uint256 b) internal pure returns (uint256) { return sub(a, b, "SafeMath: subtraction overflow"); } function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) { require(b <= a, errorMessage); uint256 c = a - b; return c; } function mul(uint256 a, uint256 b) internal pure returns (uint256) { if (a == 0) { return 0; } uint256 c = a * b; require(c / a == b, "SafeMath: multiplication overflow"); return c; } function div(uint256 a, uint256 b) internal pure returns (uint256) { return div(a, b, "SafeMath: division by zero"); } function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) { require(b > 0, errorMessage); uint256 c = a / b; return c; } function mod(uint256 a, uint256 b) internal pure returns (uint256) { return mod(a, b, "SafeMath: modulo by zero"); } function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) { require(b != 0, errorMessage); return a % b; } function sqrt(uint256 x) internal pure returns(uint256 y) { uint256 z = ((add(x, 1)) / 2); y = x; while (z < y) { y = z; z = ((add((x / z), z)) / 2); } } function sq(uint256 x) internal pure returns(uint256) { return (mul(x, x)); } function pwr(uint256 x, uint256 y) internal pure returns(uint256) { if (x == 0) return (0); else if (y == 0) return (1); else { uint256 z = x; for (uint256 i = 1; i < y; i++) z = mul(z, x); return (z); } } } pragma solidity ^0.5.10; contract ECOPToken is IERC20, owned { string public constant name = "ECOP Token"; string public constant symbol = "ECOP"; uint8 public constant decimals = 18; event Approval(address indexed tokenOwner, address indexed spender, uint tokens); event Transfer(address indexed from, address indexed to, uint tokens); event FrozenFunds(address target, bool frozen); mapping(address => uint256) balances; mapping(address => mapping (address => uint256)) allowed; uint256 totalSupply_; using SafeMath for uint256; constructor() public { totalSupply_ = 49000000 * 10 ** uint256(decimals); balances[msg.sender] = totalSupply_; }

function totalSupply() external view returns (uint256) { return totalSupply_; } function balanceOf(address account) external view returns (uint256) { return balances[account]; } function allowance(address owner, address spender) external view returns (uint256) { return allowed[owner][spender]; } function decimals() external view returns (uint8) { return decimals; } function transfer(address recipient, uint256 amount) external returns (bool) { _transfer(msg.sender, recipient, amount); return true; } function approve(address spender, uint256 amount) external returns (bool) { _approve(msg.sender, spender, amount); return true; } function transferFrom(address sender, address recipient, uint256 amount) external returns (bool) { _transfer(sender, recipient, amount); _approve(sender, msg.sender, allowed[sender][msg.sender].sub(amount, "ERC20: transfer amount exceeds allowance")); return true; } function burn(uint256 _value) external returns (bool success) { _burn(msg.sender, _value); return true; } function burnFrom(address _from, uint256 _value) external returns (bool success) { _burnFrom(_from, _value); return true; } function _transfer(address sender, address recipient, uint256 amount) internal { require(sender != address(0), "ERC20: transfer from the zero address"); require(recipient != address(0), "ERC20: transfer to the zero address"); balances[sender] = balances[sender].sub(amount, "ERC20: transfer amount exceeds balance"); balances[recipient] = balances[recipient].add(amount); emit Transfer(sender, recipient, amount); }

function _approve(address owner, address spender, uint256 amount) internal { require(owner != address(0), "ERC20: approve from the zero address"); require(spender != address(0), "ERC20: approve to the zero address"); allowed[owner][spender] = amount; emit Approval(owner, spender, amount); }

function _burn(address account, uint256 amount) internal { require(account != address(0), "ERC20: burn from the zero address"); balances[account] = balances[account].sub(amount, "ERC20: burn amount exceeds balance"); totalSupply_ = totalSupply_.sub(amount); emit Transfer(account, address(0), amount); }