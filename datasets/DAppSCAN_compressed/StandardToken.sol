pragma solidity 0.8.5;

contract Ownable { address public owner; event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); modifier onlyOwner() { require(msg.sender == owner, "Ownable: caller is not the owner"); _; }

function transferOwnership(address newOwner) public onlyOwner { require(newOwner != address(0), "Ownable: new owner is the zero address"); emit OwnershipTransferred(owner, newOwner); owner = newOwner; } } contract Pausable is Ownable { event Pause(); event Unpause(); bool public paused = false; modifier whenNotPaused() { require(!paused, "Pausable: paused"); _; } modifier whenPaused() { require(paused, "Pausable: not paused"); _; } function pause() public onlyOwner whenNotPaused { paused = true; emit Pause(); } function unpause() public onlyOwner whenPaused { paused = false; emit Unpause(); } } interface IBEP20 { function balanceOf(address account) external view returns (uint256); function transfer(address recipient, uint256 amount) external returns (bool); } interface IDEXFactory { function createPair(address tokenA, address tokenB) external returns (address pair); } interface IDEXRouter { function factory() external pure returns (address); function addLiquidityETH(address token, uint256 amountTokenDesired, uint256 amountTokenMin, uint256 amountETHMin, address to, uint256 deadline) external payable returns (uint256 amountToken, uint256 amountETH, uint256 liquidity); function swapExactTokensForETHSupportingFeeOnTransferTokens(uint256 amountIn, uint256 amountOutMin, address[] calldata path, address to, uint256 deadline) external; } contract StandardToken is Ownable, Pausable { string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; mapping (address => mapping(address => uint256)) public allowance; mapping(address => uint256) public balanceOf; address holdersWallet; address public pair; IDEXRouter public router; address public WBNB = 0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c; struct FeeSettings { uint256 liquidity; uint256 holders; uint256 burn; uint256 total; uint256 _denominator; } FeeSettings public fees = FeeSettings({ liquidity: 0, holders: 3, burn: 2, total: 3, _denominator: 100 }); mapping(address => bool) public isPair; uint256[2] public _SWAPBACK_THRESHOLD = [1, 10000]; bool public MINT_FORBIDDEN = false; bool inSwap; modifier swapping() { inSwap = true; _; inSwap = false; } mapping(address => bool) public tokenBlacklist; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed owner, address indexed spender, uint256 value); event Mint(address indexed from, address indexed to, uint256 value); event Burn(address indexed burner, uint256 value); event Blacklist(address indexed blackListed, bool value); event Pair(address indexed excluded, bool value); receive() external payable {}

function transfer(address _to, uint256 _value) public whenNotPaused returns (bool) { require(!tokenBlacklist[msg.sender], "TokenBlacklist: Sender is blacklisted"); require(_to != address(0), "Transfer to the zero address"); _transfer(msg.sender, _to, _value); return true; } function transferFrom(address _from, address _to, uint256 _value) public whenNotPaused returns (bool) { require(!tokenBlacklist[msg.sender], "TokenBlacklist: Sender is blacklisted"); require(_to != address(0), "Transfer to the zero address"); if (allowance[_from][msg.sender] < ~uint256(0)) allowance[_from][msg.sender] -= _value; _transfer(_from, _to, _value); return true; } function _transfer(address _from, address _to, uint256 _value) internal { uint256 tempValue = _value; bool _fee = isPair[_to]; if (_fee) { //tempValue -= _substractBurn(_from, _value); //tempValue -= _substractFees(_from, _value); //_sellAndDistributeAccumulatedTKNFee(); }